#!/bin/bash
#
# vern-discovery: Run the full Vern Discovery Pipeline
#
# Usage:
#   Interactive:
#     vern-discovery "<idea>" [discovery_dir] [output_format]
#
#   Batch (non-interactive, for skill/plugin use):
#     vern-discovery --batch "<idea>" [discovery_dir] [output_format]
#     vern-discovery --batch --skip-input --vernhole 8 "<idea>" [discovery_dir] [output_format]
#
# Flags:
#   --batch          Non-interactive mode. Auto-reads input files, skips prompts.
#   --skip-input     In batch mode, don't read input/ files as context.
#   --vernhole N     After pipeline, run VernHole with N verns (0 to skip, default: skip).
#   --extra-context FILE  Add an extra context file (can be used multiple times).
#
# Reads pipeline config from ~/.claude/vern-bot-config.json if it exists,
# otherwise falls back to defaults (codex/claude/gemini).
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VERN_RUN="$SCRIPT_DIR/vern-run"
CONFIG_FILE="$HOME/.claude/vern-bot-config.json"
DEFAULT_CONFIG="$SCRIPT_DIR/../config.default.json"

# Parse flags
BATCH_MODE=0
READ_INPUT=1
VERNHOLE_COUNT=0
EXTRA_CONTEXT_FILES=()

while [[ "$1" == --* ]]; do
    case "$1" in
        --batch)
            BATCH_MODE=1
            shift
            ;;
        --skip-input)
            READ_INPUT=0
            shift
            ;;
        --vernhole)
            VERNHOLE_COUNT="$2"
            shift 2
            ;;
        --extra-context)
            EXTRA_CONTEXT_FILES+=("$2")
            shift 2
            ;;
        *)
            echo "Unknown flag: $1"
            shift
            ;;
    esac
done

IDEA="$1"
DISCOVERY_DIR="$2"
OUTPUT_FORMAT="${3:-tasks}"

if [ -z "$IDEA" ]; then
    echo "Usage: vern-discovery [flags] \"<idea>\" [discovery_dir] [output_format]"
    echo ""
    echo "Flags:"
    echo "  --batch              Non-interactive mode (for skill/plugin use)"
    echo "  --skip-input         Don't read input/ files as context"
    echo "  --vernhole N         Run VernHole with N verns after pipeline"
    echo "  --extra-context FILE Add extra context file (repeatable)"
    exit 1
fi

# Load config - user config takes priority, then default, then hardcoded fallback
get_step_config() {
    local step_num="$1"
    local field="$2"
    local config_source="$CONFIG_FILE"

    if [ ! -f "$config_source" ]; then
        config_source="$DEFAULT_CONFIG"
    fi

    if [ -f "$config_source" ] && command -v python3 &>/dev/null; then
        python3 -c "
import json, sys
with open('$config_source') as f:
    cfg = json.load(f)
for step in cfg.get('discovery_pipeline', []):
    if step.get('step') == $step_num:
        print(step.get('$field', ''))
        sys.exit(0)
print('')
" 2>/dev/null
    fi
}

# Read pipeline config for each step
STEP1_LLM=$(get_step_config 1 llm)
STEP1_PROMPT=$(get_step_config 1 prompt_prefix)
STEP2_LLM=$(get_step_config 2 llm)
STEP2_PROMPT=$(get_step_config 2 prompt_prefix)
STEP3_LLM=$(get_step_config 3 llm)
STEP3_PROMPT=$(get_step_config 3 prompt_prefix)
STEP4_LLM=$(get_step_config 4 llm)
STEP4_PROMPT=$(get_step_config 4 prompt_prefix)
STEP5_LLM=$(get_step_config 5 llm)
STEP5_PROMPT=$(get_step_config 5 prompt_prefix)

# Fallback defaults if config couldn't be read
STEP1_LLM="${STEP1_LLM:-codex}"
STEP1_PROMPT="${STEP1_PROMPT:-You are MightyVern. Analyze this idea and provide comprehensive initial analysis including: problem space, technical requirements, proposed architecture, unknowns and risks.}"
STEP2_LLM="${STEP2_LLM:-claude}"
STEP2_PROMPT="${STEP2_PROMPT:-You are Vernile the Great. Review and refine this analysis. Identify gaps, add architectural considerations, consider maintainability and elegance.}"
STEP3_LLM="${STEP3_LLM:-gemini}"
STEP3_PROMPT="${STEP3_PROMPT:-You are YOLO Vern. Challenge and stress-test this plan. What could go wrong? What unconventional approaches exist? No sacred cows.}"
STEP4_LLM="${STEP4_LLM:-codex}"
STEP4_PROMPT="${STEP4_PROMPT:-You are MightyVern. Synthesize all inputs into a master plan. Merge insights, resolve contradictions, create unified vision, prioritize features.}"
STEP5_LLM="${STEP5_LLM:-claude}"
STEP5_PROMPT="${STEP5_PROMPT:-You are Architect Vern. Break down this master plan into actionable items with: title, description, acceptance criteria, complexity (S/M/L/XL), dependencies. Think in systems. Consider failure modes. Make it maintainable.}"

# If no discovery dir provided, create one from the idea name
if [ -z "$DISCOVERY_DIR" ]; then
    PROJECT_NAME=$(echo "$IDEA" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-50)
    DISCOVERY_DIR="./discovery/$PROJECT_NAME"
fi

INPUT_DIR="$DISCOVERY_DIR/input"
OUTPUT_DIR="$DISCOVERY_DIR/output"

echo "=== VERN DISCOVERY PIPELINE ==="
echo "Idea: $IDEA"
echo "Discovery folder: $DISCOVERY_DIR"
echo "Format: $OUTPUT_FORMAT"
if [ "$BATCH_MODE" -eq 1 ]; then
    echo "Mode: batch (non-interactive)"
fi
if [ -f "$CONFIG_FILE" ]; then
    echo "Config: $CONFIG_FILE"
else
    echo "Config: defaults (run /setup to customize)"
fi
echo ""
echo "Pipeline:"
echo "  1. $(get_step_config 1 name 2>/dev/null || echo 'Initial Analysis') → $STEP1_LLM"
echo "  2. $(get_step_config 2 name 2>/dev/null || echo 'Refinement') → $STEP2_LLM"
echo "  3. $(get_step_config 3 name 2>/dev/null || echo 'Chaos Check') → $STEP3_LLM"
echo "  4. $(get_step_config 4 name 2>/dev/null || echo 'Consolidation') → $STEP4_LLM"
echo "  5. $(get_step_config 5 name 2>/dev/null || echo 'Architect Breakdown') → $STEP5_LLM"
echo ""

# Create directory structure
mkdir -p "$INPUT_DIR"
mkdir -p "$OUTPUT_DIR/$OUTPUT_FORMAT"

# Save prompt if prompt.md doesn't already exist
if [ ! -f "$INPUT_DIR/prompt.md" ]; then
    cat > "$INPUT_DIR/prompt.md" << PROMPTEOF
# Discovery Prompt

$IDEA
PROMPTEOF
    echo "Saved prompt to $INPUT_DIR/prompt.md"
fi

# Build context from input files
INPUT_CONTEXT=""
INPUT_FILES=$(find "$INPUT_DIR" -type f \( -name '*.md' -o -name '*.txt' -o -name '*.json' -o -name '*.yaml' -o -name '*.yml' \) 2>/dev/null | sort)

if [ -n "$INPUT_FILES" ]; then
    echo "Found input files:"
    echo "$INPUT_FILES" | while read -r f; do echo "  - $(basename "$f")"; done
    echo ""

    if [ "$BATCH_MODE" -eq 1 ]; then
        # Batch mode: use READ_INPUT flag (default: yes)
        if [ "$READ_INPUT" -eq 1 ]; then
            while IFS= read -r file; do
                INPUT_CONTEXT="$INPUT_CONTEXT

=== $(basename "$file") ===
$(cat "$file")
"
            done <<< "$INPUT_FILES"
            echo "Loaded $(echo "$INPUT_FILES" | wc -l | tr -d ' ') input files as context."
        else
            echo "Skipping input files (--skip-input)."
        fi
    else
        # Interactive mode: ask user
        read -p ">>> Read input files as context for discovery? [Y/n] " READ_INPUT_ANSWER
        if [[ ! "$READ_INPUT_ANSWER" =~ ^[Nn]$ ]]; then
            while IFS= read -r file; do
                INPUT_CONTEXT="$INPUT_CONTEXT

=== $(basename "$file") ===
$(cat "$file")
"
            done <<< "$INPUT_FILES"
            echo "Loaded $(echo "$INPUT_FILES" | wc -l | tr -d ' ') input files as context."
        fi
    fi
fi

# Extra context files (from --extra-context flags)
for EXTRA_FILE in "${EXTRA_CONTEXT_FILES[@]}"; do
    if [ -f "$EXTRA_FILE" ]; then
        INPUT_CONTEXT="$INPUT_CONTEXT

=== $(basename "$EXTRA_FILE") ===
$(cat "$EXTRA_FILE")
"
        echo "Added extra context: $EXTRA_FILE"
    else
        echo "Warning: Extra context file not found: $EXTRA_FILE"
    fi
done

if [ "$BATCH_MODE" -eq 0 ]; then
    # Interactive mode: ask about additional files
    read -p ">>> Add any other files as context? [y/N] " ADD_MORE
    while [[ "$ADD_MORE" =~ ^[Yy]$ ]]; do
        read -p "File path: " EXTRA_FILE
        if [ -f "$EXTRA_FILE" ]; then
            INPUT_CONTEXT="$INPUT_CONTEXT

=== $(basename "$EXTRA_FILE") ===
$(cat "$EXTRA_FILE")
"
            echo "Added: $EXTRA_FILE"
        else
            echo "File not found: $EXTRA_FILE"
        fi
        read -p ">>> Add another file? [y/N] " ADD_MORE
    done
fi

# Build full prompt
FULL_PROMPT="$IDEA"
if [ -n "$INPUT_CONTEXT" ]; then
    FULL_PROMPT="$FULL_PROMPT

=== INPUT MATERIALS ===
$INPUT_CONTEXT
=== END INPUT MATERIALS ==="
fi

echo ""
echo ">>> Pass 1: $(get_step_config 1 name 2>/dev/null || echo 'Initial Analysis') ($STEP1_LLM)"
"$VERN_RUN" "$STEP1_LLM" "$STEP1_PROMPT

$FULL_PROMPT" "$OUTPUT_DIR/01-codex-analysis.md"

echo ""
echo ">>> Pass 2: $(get_step_config 2 name 2>/dev/null || echo 'Refinement') ($STEP2_LLM)"
PASS1_OUTPUT=$(cat "$OUTPUT_DIR/01-codex-analysis.md")
"$VERN_RUN" "$STEP2_LLM" "$STEP2_PROMPT

ORIGINAL REQUEST:
$FULL_PROMPT

PREVIOUS ANALYSIS:
$PASS1_OUTPUT" "$OUTPUT_DIR/02-claude-refinement.md"

echo ""
echo ">>> Pass 3: $(get_step_config 3 name 2>/dev/null || echo 'Chaos Check') ($STEP3_LLM)"
PASS2_OUTPUT=$(cat "$OUTPUT_DIR/02-claude-refinement.md")
"$VERN_RUN" "$STEP3_LLM" "$STEP3_PROMPT

ORIGINAL REQUEST:
$FULL_PROMPT

REFINED PLAN:
$PASS2_OUTPUT" "$OUTPUT_DIR/03-gemini-chaos.md"

echo ""
echo ">>> Pass 4: $(get_step_config 4 name 2>/dev/null || echo 'Consolidation') ($STEP4_LLM)"
PASS3_OUTPUT=$(cat "$OUTPUT_DIR/03-gemini-chaos.md")
"$VERN_RUN" "$STEP4_LLM" "$STEP4_PROMPT

ORIGINAL REQUEST:
$FULL_PROMPT

Analysis: $PASS1_OUTPUT

Refinement: $PASS2_OUTPUT

Chaos Check: $PASS3_OUTPUT" "$OUTPUT_DIR/04-master-plan.md"

echo ""
echo ">>> Pass 5: $(get_step_config 5 name 2>/dev/null || echo 'Architect Breakdown') ($STEP5_LLM)"
MASTER_PLAN=$(cat "$OUTPUT_DIR/04-master-plan.md")
"$VERN_RUN" "$STEP5_LLM" "$STEP5_PROMPT

Format: $OUTPUT_FORMAT

ORIGINAL REQUEST:
$FULL_PROMPT

Master plan: $MASTER_PLAN" "$OUTPUT_DIR/05-architect-breakdown.md"

echo ""
echo "=== DISCOVERY COMPLETE ==="
echo "Files created in: $DISCOVERY_DIR"
echo ""
echo "Structure:"
echo "  $DISCOVERY_DIR/"
echo "  ├── input/"
ls "$INPUT_DIR" 2>/dev/null | while read -r f; do echo "  │   ├── $f"; done
echo "  └── output/"
ls "$OUTPUT_DIR" 2>/dev/null | while read -r f; do echo "      ├── $f"; done

# VernHole: batch mode uses flag, interactive mode asks
if [ "$BATCH_MODE" -eq 1 ]; then
    if [ "$VERNHOLE_COUNT" -gt 0 ]; then
        echo ""
        echo "=== ENTERING THE VERNHOLE ==="
        echo "Feeding original idea + master plan into the chaos..."
        mkdir -p "$DISCOVERY_DIR/vernhole"
        "$SCRIPT_DIR/vernhole" "$IDEA" "$DISCOVERY_DIR" "$VERNHOLE_COUNT" "$OUTPUT_DIR/04-master-plan.md"
    fi
else
    echo ""
    read -p ">>> Do you want to run a VernHole (k-hole) on the synthesised plan? [y/N] " RUN_KHOLE
    if [[ "$RUN_KHOLE" =~ ^[Yy]$ ]]; then
        echo ""
        echo "=== ENTERING THE VERNHOLE ==="
        echo "Feeding original idea + master plan into the chaos..."
        mkdir -p "$DISCOVERY_DIR/vernhole"
        "$SCRIPT_DIR/vernhole" "$IDEA" "$DISCOVERY_DIR" "" "$OUTPUT_DIR/04-master-plan.md"
    fi
fi
