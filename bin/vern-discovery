#!/bin/bash
#
# vern-discovery: Run the full Vern Discovery Pipeline
#
# Usage:
#   Interactive:
#     vern-discovery "<idea>" [discovery_dir] [output_format]
#
#   Batch (non-interactive, for skill/plugin use):
#     vern-discovery --batch "<idea>" [discovery_dir] [output_format]
#     vern-discovery --batch --skip-input --vernhole 8 "<idea>" [discovery_dir] [output_format]
#
# Flags:
#   --batch          Non-interactive mode. Auto-reads input files, skips prompts.
#   --skip-input     In batch mode, don't read input/ files as context.
#   --vernhole N     After pipeline, run VernHole with N verns (0 to skip, default: skip).
#   --expanded       Use 7-step expanded pipeline (overrides config pipeline_mode).
#   --extra-context FILE  Add an extra context file (can be used multiple times).
#
# Reads pipeline config from ~/.claude/vern-bot-config.json if it exists,
# otherwise falls back to defaults (codex/claude/gemini).
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VERN_RUN="$SCRIPT_DIR/vern-run"
CONFIG_FILE="$HOME/.claude/vern-bot-config.json"
DEFAULT_CONFIG="$SCRIPT_DIR/../config.default.json"

# Parse flags
BATCH_MODE=0
READ_INPUT=1
VERNHOLE_COUNT=0
EXPANDED_FLAG=0
EXTRA_CONTEXT_FILES=()

while [[ "$1" == --* ]]; do
    case "$1" in
        --batch)
            BATCH_MODE=1
            shift
            ;;
        --skip-input)
            READ_INPUT=0
            shift
            ;;
        --vernhole)
            VERNHOLE_COUNT="$2"
            shift 2
            ;;
        --expanded)
            EXPANDED_FLAG=1
            shift
            ;;
        --extra-context)
            EXTRA_CONTEXT_FILES+=("$2")
            shift 2
            ;;
        *)
            echo "Unknown flag: $1"
            shift
            ;;
    esac
done

IDEA="$1"
DISCOVERY_DIR="$2"
OUTPUT_FORMAT="${3:-tasks}"

if [ -z "$IDEA" ]; then
    echo "Usage: vern-discovery [flags] \"<idea>\" [discovery_dir] [output_format]"
    echo ""
    echo "Flags:"
    echo "  --batch              Non-interactive mode (for skill/plugin use)"
    echo "  --skip-input         Don't read input/ files as context"
    echo "  --vernhole N         Run VernHole with N verns after pipeline"
    echo "  --expanded           Use 7-step expanded pipeline"
    echo "  --extra-context FILE Add extra context file (repeatable)"
    exit 1
fi

# ── Load pipeline configuration ──────────────────────────────────────────────
# Determines which pipeline (default/expanded) to use and loads step configs
# into indexed shell variables for bash 3.2 compatibility (no associative arrays).
#
# Variables produced per step:  STEP_{N}_NAME, STEP_{N}_LLM, STEP_{N}_PROMPT,
#                               STEP_{N}_PERSONA, STEP_{N}_CONTEXT_MODE
# Also sets:  PIPELINE_TOTAL, PIPELINE_MODE

load_pipeline() {
    local config_source="$CONFIG_FILE"
    if [ ! -f "$config_source" ]; then
        config_source="$DEFAULT_CONFIG"
    fi

    # Determine pipeline mode: --expanded flag overrides config
    if [ "$EXPANDED_FLAG" -eq 1 ]; then
        PIPELINE_MODE="expanded"
    else
        PIPELINE_MODE="default"
    fi

    if [ -f "$config_source" ] && command -v python3 &>/dev/null; then
        # Use python3 to parse config and emit shell variable assignments
        eval "$(python3 -c "
import json, sys, re

with open('$config_source') as f:
    cfg = json.load(f)

mode = '$PIPELINE_MODE'

# Backward compat: old configs have 'discovery_pipeline' (singular array)
if 'discovery_pipelines' in cfg:
    pipelines = cfg['discovery_pipelines']
    # If --expanded not forced, respect config pipeline_mode
    if '$EXPANDED_FLAG' == '0' and 'pipeline_mode' in cfg:
        mode = cfg['pipeline_mode']
    pipeline = pipelines.get(mode, pipelines.get('default', []))
elif 'discovery_pipeline' in cfg:
    # Old format — treat as default, ignore expanded request
    pipeline = cfg['discovery_pipeline']
    mode = 'default'
else:
    pipeline = []

print('PIPELINE_MODE=\"{}\"'.format(mode))
print('PIPELINE_TOTAL={}'.format(len(pipeline)))

for step in pipeline:
    n = step.get('step', 0)
    def shell_escape(s):
        return s.replace(\"'\", \"'\\\"'\\\"'\")
    print(\"STEP_{}_NAME='{}'\".format(n, shell_escape(step.get('name', ''))))
    print(\"STEP_{}_LLM='{}'\".format(n, shell_escape(step.get('llm', ''))))
    print(\"STEP_{}_PROMPT='{}'\".format(n, shell_escape(step.get('prompt_prefix', ''))))
    print(\"STEP_{}_PERSONA='{}'\".format(n, shell_escape(step.get('persona', ''))))
    print(\"STEP_{}_CONTEXT_MODE='{}'\".format(n, shell_escape(step.get('context_mode', 'previous'))))
" 2>/dev/null)" || true
    fi
}

load_pipeline

# ── Fallback defaults (no config + no python3) ──────────────────────────────
if [ -z "$PIPELINE_TOTAL" ] || [ "$PIPELINE_TOTAL" -eq 0 ]; then
    if [ "$EXPANDED_FLAG" -eq 1 ]; then
        PIPELINE_MODE="expanded"
        PIPELINE_TOTAL=7
        STEP_1_NAME="Initial Analysis";    STEP_1_LLM="codex";  STEP_1_PERSONA="mighty";    STEP_1_CONTEXT_MODE="prompt_only"
        STEP_1_PROMPT="You are MightyVern. Analyze this idea and provide comprehensive initial analysis including: problem space, technical requirements, proposed architecture, unknowns and risks."
        STEP_2_NAME="Refinement";          STEP_2_LLM="claude";  STEP_2_PERSONA="great";  STEP_2_CONTEXT_MODE="previous"
        STEP_2_PROMPT="You are Vernile the Great. Review and refine this analysis. Identify gaps, add architectural considerations, consider maintainability and elegance."
        STEP_3_NAME="Reality Check";       STEP_3_LLM="claude";  STEP_3_PERSONA="mediocre";  STEP_3_CONTEXT_MODE="previous"
        STEP_3_PROMPT="You are Vern the Mediocre. Reality-check this plan. What's over-engineered? What can be simplified? Where is cleverness hiding complexity? Cut the fluff, keep what ships."
        STEP_4_NAME="Chaos Check";         STEP_4_LLM="gemini";  STEP_4_PERSONA="yolo";      STEP_4_CONTEXT_MODE="previous"
        STEP_4_PROMPT="You are YOLO Vern. Challenge and stress-test this plan. What could go wrong? What unconventional approaches exist? No sacred cows."
        STEP_5_NAME="MVP Lens";            STEP_5_LLM="claude";  STEP_5_PERSONA="startup";   STEP_5_CONTEXT_MODE="previous"
        STEP_5_PROMPT="You are Startup Vern. What's the MVP here? Cut scope ruthlessly. What can ship in week one? What's a nice-to-have disguised as a must-have? If you're not embarrassed by v1, you shipped too late."
        STEP_6_NAME="Consolidation";       STEP_6_LLM="codex";   STEP_6_PERSONA="mighty";    STEP_6_CONTEXT_MODE="all_previous"
        STEP_6_PROMPT="You are MightyVern. Synthesize all inputs into a master plan. Merge insights, resolve contradictions, create unified vision, prioritize features."
        STEP_7_NAME="Architect Breakdown";  STEP_7_LLM="claude";  STEP_7_PERSONA="architect"; STEP_7_CONTEXT_MODE="consolidation"
        STEP_7_PROMPT="You are Architect Vern. Break down this master plan into actionable tasks. Format each task with an h3 header exactly like this: ### TASK 1: Title Here. Include for each task: description, acceptance criteria, complexity (S/M/L/XL), dependencies. Think in systems. Consider failure modes. Make it maintainable."
    else
        PIPELINE_MODE="default"
        PIPELINE_TOTAL=5
        STEP_1_NAME="Initial Analysis";    STEP_1_LLM="codex";  STEP_1_PERSONA="mighty";    STEP_1_CONTEXT_MODE="prompt_only"
        STEP_1_PROMPT="You are MightyVern. Analyze this idea and provide comprehensive initial analysis including: problem space, technical requirements, proposed architecture, unknowns and risks."
        STEP_2_NAME="Refinement";          STEP_2_LLM="claude";  STEP_2_PERSONA="great";  STEP_2_CONTEXT_MODE="previous"
        STEP_2_PROMPT="You are Vernile the Great. Review and refine this analysis. Identify gaps, add architectural considerations, consider maintainability and elegance."
        STEP_3_NAME="Chaos Check";         STEP_3_LLM="gemini";  STEP_3_PERSONA="yolo";      STEP_3_CONTEXT_MODE="previous"
        STEP_3_PROMPT="You are YOLO Vern. Challenge and stress-test this plan. What could go wrong? What unconventional approaches exist? No sacred cows."
        STEP_4_NAME="Consolidation";       STEP_4_LLM="codex";   STEP_4_PERSONA="mighty";    STEP_4_CONTEXT_MODE="all_previous"
        STEP_4_PROMPT="You are MightyVern. Synthesize all inputs into a master plan. Merge insights, resolve contradictions, create unified vision, prioritize features."
        STEP_5_NAME="Architect Breakdown";  STEP_5_LLM="claude";  STEP_5_PERSONA="architect"; STEP_5_CONTEXT_MODE="consolidation"
        STEP_5_PROMPT="You are Architect Vern. Break down this master plan into actionable tasks. Format each task with an h3 header exactly like this: ### TASK 1: Title Here. Include for each task: description, acceptance criteria, complexity (S/M/L/XL), dependencies. Think in systems. Consider failure modes. Make it maintainable."
    fi
fi

# ── Helper: slugify a string ─────────────────────────────────────────────────
slugify() {
    echo "$1" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//;s/-$//'
}

# ── Helper: get step variable by index ────────────────────────────────────────
get_step_var() {
    local idx="$1" field="$2"
    eval echo "\"\$STEP_${idx}_${field}\""
}

# If no discovery dir provided, create one from the idea name
if [ -z "$DISCOVERY_DIR" ]; then
    PROJECT_NAME=$(echo "$IDEA" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-50)
    DISCOVERY_DIR="./discovery/$PROJECT_NAME"
fi

INPUT_DIR="$DISCOVERY_DIR/input"
OUTPUT_DIR="$DISCOVERY_DIR/output"

echo "=== VERN DISCOVERY PIPELINE ==="
echo "Idea: $IDEA"
echo "Discovery folder: $DISCOVERY_DIR"
echo "Format: $OUTPUT_FORMAT"
echo "Pipeline mode: $PIPELINE_MODE ($PIPELINE_TOTAL steps)"
if [ "$BATCH_MODE" -eq 1 ]; then
    echo "Mode: batch (non-interactive)"
fi
if [ -f "$CONFIG_FILE" ]; then
    echo "Config: $CONFIG_FILE"
else
    echo "Config: defaults (run /vern:setup to customize)"
fi
echo ""
echo "Pipeline:"
for i in $(seq 1 $PIPELINE_TOTAL); do
    step_name=$(get_step_var "$i" NAME)
    step_llm=$(get_step_var "$i" LLM)
    printf "  %d. %s → %s\n" "$i" "$step_name" "$step_llm"
done
echo ""

# Create directory structure
mkdir -p "$INPUT_DIR"
mkdir -p "$OUTPUT_DIR/$OUTPUT_FORMAT"

# Save prompt if prompt.md doesn't already exist
if [ ! -f "$INPUT_DIR/prompt.md" ]; then
    cat > "$INPUT_DIR/prompt.md" << PROMPTEOF
# Discovery Prompt

$IDEA
PROMPTEOF
    echo "Saved prompt to $INPUT_DIR/prompt.md"
fi

# Build context from input files
INPUT_CONTEXT=""
INPUT_FILES=$(find "$INPUT_DIR" -type f \( -name '*.md' -o -name '*.txt' -o -name '*.json' -o -name '*.yaml' -o -name '*.yml' \) 2>/dev/null | sort)

if [ -n "$INPUT_FILES" ]; then
    echo "Found input files:"
    echo "$INPUT_FILES" | while read -r f; do echo "  - $(basename "$f")"; done
    echo ""

    if [ "$BATCH_MODE" -eq 1 ]; then
        # Batch mode: use READ_INPUT flag (default: yes)
        if [ "$READ_INPUT" -eq 1 ]; then
            while IFS= read -r file; do
                INPUT_CONTEXT="$INPUT_CONTEXT

=== $(basename "$file") ===
$(cat "$file")
"
            done <<< "$INPUT_FILES"
            echo "Loaded $(echo "$INPUT_FILES" | wc -l | tr -d ' ') input files as context."
        else
            echo "Skipping input files (--skip-input)."
        fi
    else
        # Interactive mode: ask user
        read -p ">>> Read input files as context for discovery? [Y/n] " READ_INPUT_ANSWER
        if [[ ! "$READ_INPUT_ANSWER" =~ ^[Nn]$ ]]; then
            while IFS= read -r file; do
                INPUT_CONTEXT="$INPUT_CONTEXT

=== $(basename "$file") ===
$(cat "$file")
"
            done <<< "$INPUT_FILES"
            echo "Loaded $(echo "$INPUT_FILES" | wc -l | tr -d ' ') input files as context."
        fi
    fi
fi

# Extra context files (from --extra-context flags)
for EXTRA_FILE in "${EXTRA_CONTEXT_FILES[@]}"; do
    if [ -f "$EXTRA_FILE" ]; then
        INPUT_CONTEXT="$INPUT_CONTEXT

=== $(basename "$EXTRA_FILE") ===
$(cat "$EXTRA_FILE")
"
        echo "Added extra context: $EXTRA_FILE"
    else
        echo "Warning: Extra context file not found: $EXTRA_FILE"
    fi
done

if [ "$BATCH_MODE" -eq 0 ]; then
    # Interactive mode: ask about additional files
    read -p ">>> Add any other files as context? [y/N] " ADD_MORE
    while [[ "$ADD_MORE" =~ ^[Yy]$ ]]; do
        read -p "File path: " EXTRA_FILE
        if [ -f "$EXTRA_FILE" ]; then
            INPUT_CONTEXT="$INPUT_CONTEXT

=== $(basename "$EXTRA_FILE") ===
$(cat "$EXTRA_FILE")
"
            echo "Added: $EXTRA_FILE"
        else
            echo "File not found: $EXTRA_FILE"
        fi
        read -p ">>> Add another file? [y/N] " ADD_MORE
    done
fi

# Build full prompt
FULL_PROMPT="$IDEA"
if [ -n "$INPUT_CONTEXT" ]; then
    FULL_PROMPT="$FULL_PROMPT

=== INPUT MATERIALS ===
$INPUT_CONTEXT
=== END INPUT MATERIALS ==="
fi

# ── Dynamic pipeline execution ───────────────────────────────────────────────
# Tracks outputs for context chaining. Uses indexed arrays for bash 3.2 compat.
CONSOLIDATION_FILE=""

for i in $(seq 1 $PIPELINE_TOTAL); do
    step_name=$(get_step_var "$i" NAME)
    step_llm=$(get_step_var "$i" LLM)
    step_prompt=$(get_step_var "$i" PROMPT)
    step_persona=$(get_step_var "$i" PERSONA)
    step_context_mode=$(get_step_var "$i" CONTEXT_MODE)

    # Build dynamic output filename: NN-persona-slug-step-name-slug.md
    step_num=$(printf "%02d" "$i")
    persona_slug=$(slugify "$step_persona")
    name_slug=$(slugify "$step_name")
    output_file="$OUTPUT_DIR/${step_num}-${persona_slug}-${name_slug}.md"

    echo ""
    echo ">>> Pass $i/$PIPELINE_TOTAL: $step_name ($step_llm)"

    # Build the prompt based on context_mode
    case "$step_context_mode" in
        prompt_only)
            # Only the original idea + input materials
            run_prompt="$step_prompt

$FULL_PROMPT"
            ;;

        previous)
            # Original prompt + previous step's output only
            prev=$((i - 1))
            prev_file=$(get_step_var "$prev" OUTPUT_FILE)
            prev_output=""
            if [ -n "$prev_file" ] && [ -f "$prev_file" ]; then
                prev_output=$(cat "$prev_file")
            fi
            run_prompt="$step_prompt

ORIGINAL REQUEST:
$FULL_PROMPT

PREVIOUS ANALYSIS:
$prev_output"
            ;;

        all_previous)
            # Original prompt + all previous step outputs (consolidation)
            all_context=""
            for j in $(seq 1 $((i - 1))); do
                prev_name=$(get_step_var "$j" NAME)
                prev_file=$(get_step_var "$j" OUTPUT_FILE)
                if [ -n "$prev_file" ] && [ -f "$prev_file" ]; then
                    all_context="$all_context

$prev_name: $(cat "$prev_file")"
                fi
            done
            run_prompt="$step_prompt

ORIGINAL REQUEST:
$FULL_PROMPT
$all_context"
            # Track this as the consolidation file
            CONSOLIDATION_FILE="$output_file"
            ;;

        consolidation)
            # Original prompt + consolidation output only
            consol_output=""
            if [ -n "$CONSOLIDATION_FILE" ] && [ -f "$CONSOLIDATION_FILE" ]; then
                consol_output=$(cat "$CONSOLIDATION_FILE")
            fi
            run_prompt="$step_prompt

Format: $OUTPUT_FORMAT

ORIGINAL REQUEST:
$FULL_PROMPT

Master plan: $consol_output"
            ;;

        *)
            # Fallback: treat like previous
            prev=$((i - 1))
            prev_file=$(get_step_var "$prev" OUTPUT_FILE)
            prev_output=""
            if [ -n "$prev_file" ] && [ -f "$prev_file" ]; then
                prev_output=$(cat "$prev_file")
            fi
            run_prompt="$step_prompt

ORIGINAL REQUEST:
$FULL_PROMPT

PREVIOUS ANALYSIS:
$prev_output"
            ;;
    esac

    "$VERN_RUN" "$step_llm" "$run_prompt" "$output_file" "$step_persona"

    # Store output file path for later steps to reference
    eval "STEP_${i}_OUTPUT_FILE=\"$output_file\""
done

# ── Post-processing: split architect breakdown into individual task files ─────
# The last step (architect breakdown) outputs tasks in a single file. Split them
# into individual files in $OUTPUT_DIR/$OUTPUT_FORMAT/ and rewrite the main file
# as a summary with a task index + dependency graph + failure modes.

ARCHITECT_FILE=$(get_step_var "$PIPELINE_TOTAL" OUTPUT_FILE)

if [ -f "$ARCHITECT_FILE" ] && [ -s "$ARCHITECT_FILE" ] && command -v python3 &>/dev/null; then
    echo ""
    echo ">>> Splitting architect breakdown into individual $OUTPUT_FORMAT files..."
    ARCHITECT_FILE="$ARCHITECT_FILE" FORMAT_DIR="$OUTPUT_DIR/$OUTPUT_FORMAT" python3 << 'PYEOF'
import re, os, sys

architect_file = os.environ['ARCHITECT_FILE']
format_dir = os.environ['FORMAT_DIR']

with open(architect_file) as f:
    content = f.read()

# Find all task headers: ### TASK N: Title (also matches ## and alternate separators)
task_pattern = re.compile(r'^#{2,3}\s+Task\s+(\d+)\s*[:\.—]\s*(.+)', re.MULTILINE | re.IGNORECASE)
matches = list(task_pattern.finditer(content))

if not matches:
    print("  No tasks found in architect breakdown, skipping split")
    sys.exit(0)

# Header: everything before the first task
header = content[:matches[0].start()].rstrip('\n- ')

# Footer: first ## header (h2, not h3) after the last task — these are summary
# sections like "## Dependency Graph", "## Failure Modes", "## Total Estimate"
footer = ''
last_task_pos = matches[-1].start()
remaining = content[last_task_pos:]
footer_match = re.search(r'^## (?!#)', remaining, re.MULTILINE)
if footer_match:
    footer_abs = last_task_pos + footer_match.start()
    # Strip any trailing --- separator before the footer
    pre = content[:footer_abs].rstrip()
    if pre.endswith('---'):
        footer_abs = len(pre) - 3
    footer = content[footer_abs:].lstrip('-').strip()
else:
    footer_abs = len(content)

# Extract individual tasks
tasks = []
for idx, match in enumerate(matches):
    task_num = int(match.group(1))
    task_title = match.group(2).strip()
    start = match.start()
    end = matches[idx + 1].start() if idx + 1 < len(matches) else footer_abs

    task_body = content[start:end].rstrip()
    # Remove trailing --- separator between tasks
    if task_body.endswith('---'):
        task_body = task_body[:-3].rstrip()
    tasks.append((task_num, task_title, task_body))

def slugify(s):
    return re.sub(r'-+', '-', re.sub(r'[^a-z0-9]+', '-', s.lower())).strip('-')

# Write individual task files
os.makedirs(format_dir, exist_ok=True)
for task_num, task_title, task_body in tasks:
    filename = "task-{:02d}-{}.md".format(task_num, slugify(task_title))
    with open(os.path.join(format_dir, filename), 'w') as f:
        f.write(task_body + '\n')
    print("  Created: {}/{}".format(os.path.basename(format_dir), filename))

# Build task index table for the summary
lines = []
lines.append("| # | Task | Complexity | Dependencies |")
lines.append("|---|------|------------|--------------|")
for task_num, task_title, task_body in tasks:
    cx = re.search(r'\*\*Complexity:\*\*\s*(\S+)', task_body)
    dp = re.search(r'\*\*Dependencies:\*\*\s*(.+)', task_body)
    lines.append("| {} | {} | {} | {} |".format(
        task_num, task_title,
        cx.group(1) if cx else '?',
        dp.group(1).strip() if dp else 'None'))
task_index = '\n'.join(lines)

# Rewrite the architect file as a summary
with open(architect_file, 'w') as f:
    f.write(header + '\n\n')
    f.write("## Task Index\n\n")
    f.write("Individual task files: `{}/`\n\n".format(os.path.basename(format_dir)))
    f.write(task_index + '\n')
    if footer:
        f.write('\n' + footer + '\n')

print("  Rewrote {} as summary ({} tasks extracted)".format(
    os.path.basename(architect_file), len(tasks)))
PYEOF
fi

echo ""
echo "=== DISCOVERY COMPLETE ==="
echo "Files created in: $DISCOVERY_DIR"
echo ""
echo "Structure:"
echo "  $DISCOVERY_DIR/"
echo "  ├── input/"
ls "$INPUT_DIR" 2>/dev/null | while read -r f; do echo "  │   ├── $f"; done
echo "  └── output/"
ls "$OUTPUT_DIR" 2>/dev/null | while read -r f; do echo "      ├── $f"; done

# VernHole: batch mode uses flag, interactive mode asks
# Use the dynamically tracked consolidation file
if [ -z "$CONSOLIDATION_FILE" ]; then
    # Fallback: find the consolidation file by name pattern
    CONSOLIDATION_FILE=$(ls "$OUTPUT_DIR"/*consolidation*.md 2>/dev/null | head -1)
fi

if [ "$BATCH_MODE" -eq 1 ]; then
    if [ "$VERNHOLE_COUNT" -gt 0 ]; then
        echo ""
        echo "=== ENTERING THE VERNHOLE ==="
        echo "Feeding original idea + master plan into the chaos..."
        mkdir -p "$DISCOVERY_DIR/vernhole"
        "$SCRIPT_DIR/vernhole" "$IDEA" "$DISCOVERY_DIR/vernhole" "$VERNHOLE_COUNT" "$CONSOLIDATION_FILE"
    fi
else
    echo ""
    read -p ">>> Do you want to run a VernHole (k-hole) on the synthesised plan? [y/N] " RUN_KHOLE
    if [[ "$RUN_KHOLE" =~ ^[Yy]$ ]]; then
        echo ""
        echo "=== ENTERING THE VERNHOLE ==="
        echo "Feeding original idea + master plan into the chaos..."
        mkdir -p "$DISCOVERY_DIR/vernhole"
        "$SCRIPT_DIR/vernhole" "$IDEA" "$DISCOVERY_DIR/vernhole" "" "$CONSOLIDATION_FILE"
    fi
fi
