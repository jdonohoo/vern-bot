#!/bin/bash
#
# vern-discovery: Run the full Vern Discovery Pipeline
#
# Usage:
#   Interactive:
#     vern-discovery "<idea>" [discovery_dir]
#
#   Batch (non-interactive, for skill/plugin use):
#     vern-discovery --batch "<idea>" [discovery_dir]
#     vern-discovery --batch --skip-input --vernhole 8 "<idea>" [discovery_dir]
#     vern-discovery --batch --vernhole-council hammers --oracle --oracle-apply "<idea>"
#
# Flags:
#   --batch          Non-interactive mode. Auto-reads input files, skips prompts.
#   --skip-input     In batch mode, don't read input/ files as context.
#   --vernhole N     After pipeline, run VernHole with N verns (0 to skip, default: skip).
#   --vernhole-council NAME  Use a named VernHole council tier (hammers, conflict, inner, round, war, full, random).
#   --oracle         After VernHole, run Oracle Vern on synthesis + VTS tasks.
#   --oracle-apply   Auto-apply Oracle's vision via Architect Vern (implies --oracle).
#   --expanded       Use 7-step expanded pipeline (overrides config pipeline_mode).
#   --extra-context FILE  Add an extra context file (can be used multiple times).
#
# Reads pipeline config from ~/.claude/vern-bot-config.json if it exists,
# otherwise falls back to defaults (codex/claude/gemini).
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VERN_RUN="$SCRIPT_DIR/vern-run"
CONFIG_FILE="$HOME/.claude/vern-bot-config.json"
DEFAULT_CONFIG="$SCRIPT_DIR/../config.default.json"

# Parse flags
BATCH_MODE=0
READ_INPUT=1
VERNHOLE_COUNT=0
VERNHOLE_COUNCIL=""
EXPANDED_FLAG=0
ORACLE_FLAG=0
ORACLE_APPLY_FLAG=0
EXTRA_CONTEXT_FILES=()

while [[ "$1" == --* ]]; do
    case "$1" in
        --batch)
            BATCH_MODE=1
            shift
            ;;
        --skip-input)
            READ_INPUT=0
            shift
            ;;
        --vernhole)
            VERNHOLE_COUNT="$2"
            shift 2
            ;;
        --vernhole-council)
            VERNHOLE_COUNCIL="$2"
            shift 2
            ;;
        --oracle)
            ORACLE_FLAG=1
            shift
            ;;
        --oracle-apply)
            ORACLE_FLAG=1
            ORACLE_APPLY_FLAG=1
            shift
            ;;
        --expanded)
            EXPANDED_FLAG=1
            shift
            ;;
        --extra-context)
            EXTRA_CONTEXT_FILES+=("$2")
            shift 2
            ;;
        *)
            echo "Unknown flag: $1"
            shift
            ;;
    esac
done

IDEA="$1"
DISCOVERY_DIR="$2"

if [ -z "$IDEA" ]; then
    echo "Usage: vern-discovery [flags] \"<idea>\" [discovery_dir]"
    echo ""
    echo "Flags:"
    echo "  --batch              Non-interactive mode (for skill/plugin use)"
    echo "  --skip-input         Don't read input/ files as context"
    echo "  --vernhole N         Run VernHole with N verns after pipeline"
    echo "  --vernhole-council NAME  Use a named council tier (hammers, conflict, inner, round, war, full, random)"
    echo "  --oracle             Run Oracle Vern after VernHole"
    echo "  --oracle-apply       Auto-apply Oracle's vision via Architect Vern"
    echo "  --expanded           Use 7-step expanded pipeline"
    echo "  --extra-context FILE Add extra context file (repeatable)"
    exit 1
fi

# ── Load pipeline configuration ──────────────────────────────────────────────
# Determines which pipeline (default/expanded) to use and loads step configs
# into indexed shell variables for bash 3.2 compatibility (no associative arrays).
#
# Variables produced per step:  STEP_{N}_NAME, STEP_{N}_LLM, STEP_{N}_PROMPT,
#                               STEP_{N}_PERSONA, STEP_{N}_CONTEXT_MODE
# Also sets:  PIPELINE_TOTAL, PIPELINE_MODE

load_pipeline() {
    local config_source="$CONFIG_FILE"
    if [ ! -f "$config_source" ]; then
        config_source="$DEFAULT_CONFIG"
    fi

    # Determine pipeline mode: --expanded flag overrides config
    if [ "$EXPANDED_FLAG" -eq 1 ]; then
        PIPELINE_MODE="expanded"
    else
        PIPELINE_MODE="default"
    fi

    if [ -f "$config_source" ] && command -v python3 &>/dev/null; then
        # Use python3 to parse config and emit shell variable assignments
        eval "$(python3 -c "
import json, sys, re

with open('$config_source') as f:
    cfg = json.load(f)

mode = '$PIPELINE_MODE'

# Backward compat: old configs have 'discovery_pipeline' (singular array)
if 'discovery_pipelines' in cfg:
    pipelines = cfg['discovery_pipelines']
    # If --expanded not forced, respect config pipeline_mode
    if '$EXPANDED_FLAG' == '0' and 'pipeline_mode' in cfg:
        mode = cfg['pipeline_mode']
    pipeline = pipelines.get(mode, pipelines.get('default', []))
elif 'discovery_pipeline' in cfg:
    # Old format — treat as default, ignore expanded request
    pipeline = cfg['discovery_pipeline']
    mode = 'default'
else:
    pipeline = []

print('PIPELINE_MODE=\"{}\"'.format(mode))
print('PIPELINE_TOTAL={}'.format(len(pipeline)))

for step in pipeline:
    n = step.get('step', 0)
    def shell_escape(s):
        return s.replace(\"'\", \"'\\\"'\\\"'\")
    print(\"STEP_{}_NAME='{}'\".format(n, shell_escape(step.get('name', ''))))
    print(\"STEP_{}_LLM='{}'\".format(n, shell_escape(step.get('llm', ''))))
    print(\"STEP_{}_PROMPT='{}'\".format(n, shell_escape(step.get('prompt_prefix', ''))))
    print(\"STEP_{}_PERSONA='{}'\".format(n, shell_escape(step.get('persona', ''))))
    print(\"STEP_{}_CONTEXT_MODE='{}'\".format(n, shell_escape(step.get('context_mode', 'previous'))))
" 2>/dev/null)" || true
    fi
}

load_pipeline

# ── Fallback defaults (no config + no python3) ──────────────────────────────
if [ -z "$PIPELINE_TOTAL" ] || [ "$PIPELINE_TOTAL" -eq 0 ]; then
    if [ "$EXPANDED_FLAG" -eq 1 ]; then
        PIPELINE_MODE="expanded"
        PIPELINE_TOTAL=7
        STEP_1_NAME="Initial Analysis";    STEP_1_LLM="codex";  STEP_1_PERSONA="mighty";    STEP_1_CONTEXT_MODE="prompt_only"
        STEP_1_PROMPT="You are MightyVern. Analyze this idea and provide comprehensive initial analysis including: problem space, technical requirements, proposed architecture, unknowns and risks."
        STEP_2_NAME="Refinement";          STEP_2_LLM="claude";  STEP_2_PERSONA="great";  STEP_2_CONTEXT_MODE="previous"
        STEP_2_PROMPT="You are Vernile the Great. Review and refine this analysis. Identify gaps, add architectural considerations, consider maintainability and elegance."
        STEP_3_NAME="Reality Check";       STEP_3_LLM="claude";  STEP_3_PERSONA="mediocre";  STEP_3_CONTEXT_MODE="previous"
        STEP_3_PROMPT="You are Vern the Mediocre. Reality-check this plan. What's over-engineered? What can be simplified? Where is cleverness hiding complexity? Cut the fluff, keep what ships."
        STEP_4_NAME="Chaos Check";         STEP_4_LLM="gemini";  STEP_4_PERSONA="yolo";      STEP_4_CONTEXT_MODE="previous"
        STEP_4_PROMPT="You are YOLO Vern. Challenge and stress-test this plan. What could go wrong? What unconventional approaches exist? No sacred cows."
        STEP_5_NAME="MVP Lens";            STEP_5_LLM="claude";  STEP_5_PERSONA="startup";   STEP_5_CONTEXT_MODE="previous"
        STEP_5_PROMPT="You are Startup Vern. What's the MVP here? Cut scope ruthlessly. What can ship in week one? What's a nice-to-have disguised as a must-have? If you're not embarrassed by v1, you shipped too late."
        STEP_6_NAME="Consolidation";       STEP_6_LLM="codex";   STEP_6_PERSONA="mighty";    STEP_6_CONTEXT_MODE="all_previous"
        STEP_6_PROMPT="You are MightyVern. Synthesize all inputs into a master plan. Merge insights, resolve contradictions, create unified vision, prioritize features."
        STEP_7_NAME="Architect Breakdown";  STEP_7_LLM="claude";  STEP_7_PERSONA="architect"; STEP_7_CONTEXT_MODE="consolidation"
        STEP_7_PROMPT="You are Architect Vern. Break down this master plan into actionable Vern Task Spec (VTS) tasks. Format each task with an h3 header exactly like this: ### TASK 1: Title Here. Include for each task: **Description:** what needs to be done, **Acceptance Criteria:** bullet list, **Complexity:** S|M|L|XL, **Dependencies:** Task N references or None, **Files:** list of files likely touched. Think in systems. Consider failure modes. Make it maintainable."
    else
        PIPELINE_MODE="default"
        PIPELINE_TOTAL=5
        STEP_1_NAME="Initial Analysis";    STEP_1_LLM="codex";  STEP_1_PERSONA="mighty";    STEP_1_CONTEXT_MODE="prompt_only"
        STEP_1_PROMPT="You are MightyVern. Analyze this idea and provide comprehensive initial analysis including: problem space, technical requirements, proposed architecture, unknowns and risks."
        STEP_2_NAME="Refinement";          STEP_2_LLM="claude";  STEP_2_PERSONA="great";  STEP_2_CONTEXT_MODE="previous"
        STEP_2_PROMPT="You are Vernile the Great. Review and refine this analysis. Identify gaps, add architectural considerations, consider maintainability and elegance."
        STEP_3_NAME="Chaos Check";         STEP_3_LLM="gemini";  STEP_3_PERSONA="yolo";      STEP_3_CONTEXT_MODE="previous"
        STEP_3_PROMPT="You are YOLO Vern. Challenge and stress-test this plan. What could go wrong? What unconventional approaches exist? No sacred cows."
        STEP_4_NAME="Consolidation";       STEP_4_LLM="codex";   STEP_4_PERSONA="mighty";    STEP_4_CONTEXT_MODE="all_previous"
        STEP_4_PROMPT="You are MightyVern. Synthesize all inputs into a master plan. Merge insights, resolve contradictions, create unified vision, prioritize features."
        STEP_5_NAME="Architect Breakdown";  STEP_5_LLM="claude";  STEP_5_PERSONA="architect"; STEP_5_CONTEXT_MODE="consolidation"
        STEP_5_PROMPT="You are Architect Vern. Break down this master plan into actionable Vern Task Spec (VTS) tasks. Format each task with an h3 header exactly like this: ### TASK 1: Title Here. Include for each task: **Description:** what needs to be done, **Acceptance Criteria:** bullet list, **Complexity:** S|M|L|XL, **Dependencies:** Task N references or None, **Files:** list of files likely touched. Think in systems. Consider failure modes. Make it maintainable."
    fi
fi

# ── Helper: slugify a string ─────────────────────────────────────────────────
slugify() {
    echo "$1" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//;s/-$//'
}

# ── Helper: get step variable by index ────────────────────────────────────────
get_step_var() {
    local idx="$1" field="$2"
    eval echo "\"\$STEP_${idx}_${field}\""
}

# If no discovery dir provided, create one from the idea name
if [ -z "$DISCOVERY_DIR" ]; then
    PROJECT_NAME=$(echo "$IDEA" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-50)
    DISCOVERY_DIR="./discovery/$PROJECT_NAME"
fi

INPUT_DIR="$DISCOVERY_DIR/input"
OUTPUT_DIR="$DISCOVERY_DIR/output"

echo "=== VERN DISCOVERY PIPELINE ==="
echo "Idea: $IDEA"
echo "Discovery folder: $DISCOVERY_DIR"
echo "Output: Vern Task Spec (VTS)"
echo "Pipeline mode: $PIPELINE_MODE ($PIPELINE_TOTAL steps)"
if [ "$BATCH_MODE" -eq 1 ]; then
    echo "Mode: batch (non-interactive)"
fi
if [ -f "$CONFIG_FILE" ]; then
    echo "Config: $CONFIG_FILE"
else
    echo "Config: defaults (run /vern:setup to customize)"
fi
echo ""
echo "Pipeline:"
for i in $(seq 1 $PIPELINE_TOTAL); do
    step_name=$(get_step_var "$i" NAME)
    step_llm=$(get_step_var "$i" LLM)
    printf "  %d. %s → %s\n" "$i" "$step_name" "$step_llm"
done
echo ""

# Create directory structure
mkdir -p "$INPUT_DIR"
mkdir -p "$OUTPUT_DIR/vts"

# Save prompt if prompt.md doesn't already exist
if [ ! -f "$INPUT_DIR/prompt.md" ]; then
    cat > "$INPUT_DIR/prompt.md" << PROMPTEOF
# Discovery Prompt

$IDEA
PROMPTEOF
    echo "Saved prompt to $INPUT_DIR/prompt.md"
fi

# Build context from input files
INPUT_CONTEXT=""
INPUT_FILES=$(find "$INPUT_DIR" -type f \( -name '*.md' -o -name '*.txt' -o -name '*.json' -o -name '*.yaml' -o -name '*.yml' \) 2>/dev/null | sort)

if [ -n "$INPUT_FILES" ]; then
    echo "Found input files:"
    echo "$INPUT_FILES" | while read -r f; do echo "  - $(basename "$f")"; done
    echo ""

    if [ "$BATCH_MODE" -eq 1 ]; then
        # Batch mode: use READ_INPUT flag (default: yes)
        if [ "$READ_INPUT" -eq 1 ]; then
            while IFS= read -r file; do
                INPUT_CONTEXT="$INPUT_CONTEXT

=== $(basename "$file") ===
$(cat "$file")
"
            done <<< "$INPUT_FILES"
            echo "Loaded $(echo "$INPUT_FILES" | wc -l | tr -d ' ') input files as context."
        else
            echo "Skipping input files (--skip-input)."
        fi
    else
        # Interactive mode: ask user
        read -p ">>> Read input files as context for discovery? [Y/n] " READ_INPUT_ANSWER
        if [[ ! "$READ_INPUT_ANSWER" =~ ^[Nn]$ ]]; then
            while IFS= read -r file; do
                INPUT_CONTEXT="$INPUT_CONTEXT

=== $(basename "$file") ===
$(cat "$file")
"
            done <<< "$INPUT_FILES"
            echo "Loaded $(echo "$INPUT_FILES" | wc -l | tr -d ' ') input files as context."
        fi
    fi
fi

# Extra context files (from --extra-context flags)
for EXTRA_FILE in "${EXTRA_CONTEXT_FILES[@]}"; do
    if [ -f "$EXTRA_FILE" ]; then
        INPUT_CONTEXT="$INPUT_CONTEXT

=== $(basename "$EXTRA_FILE") ===
$(cat "$EXTRA_FILE")
"
        echo "Added extra context: $EXTRA_FILE"
    else
        echo "Warning: Extra context file not found: $EXTRA_FILE"
    fi
done

if [ "$BATCH_MODE" -eq 0 ]; then
    # Interactive mode: ask about additional files
    read -p ">>> Add any other files as context? [y/N] " ADD_MORE
    while [[ "$ADD_MORE" =~ ^[Yy]$ ]]; do
        read -p "File path: " EXTRA_FILE
        if [ -f "$EXTRA_FILE" ]; then
            INPUT_CONTEXT="$INPUT_CONTEXT

=== $(basename "$EXTRA_FILE") ===
$(cat "$EXTRA_FILE")
"
            echo "Added: $EXTRA_FILE"
        else
            echo "File not found: $EXTRA_FILE"
        fi
        read -p ">>> Add another file? [y/N] " ADD_MORE
    done
fi

# Build full prompt
FULL_PROMPT="$IDEA"
if [ -n "$INPUT_CONTEXT" ]; then
    FULL_PROMPT="$FULL_PROMPT

=== INPUT MATERIALS ===
$INPUT_CONTEXT
=== END INPUT MATERIALS ==="
fi

# ── Dynamic pipeline execution ───────────────────────────────────────────────
# Tracks outputs for context chaining. Uses indexed arrays for bash 3.2 compat.
CONSOLIDATION_FILE=""

for i in $(seq 1 $PIPELINE_TOTAL); do
    step_name=$(get_step_var "$i" NAME)
    step_llm=$(get_step_var "$i" LLM)
    step_prompt=$(get_step_var "$i" PROMPT)
    step_persona=$(get_step_var "$i" PERSONA)
    step_context_mode=$(get_step_var "$i" CONTEXT_MODE)

    # Build dynamic output filename: NN-persona-slug-step-name-slug.md
    step_num=$(printf "%02d" "$i")
    persona_slug=$(slugify "$step_persona")
    name_slug=$(slugify "$step_name")
    output_file="$OUTPUT_DIR/${step_num}-${persona_slug}-${name_slug}.md"

    echo ""
    echo ">>> Pass $i/$PIPELINE_TOTAL: $step_name ($step_llm)"

    # Build the prompt based on context_mode
    case "$step_context_mode" in
        prompt_only)
            # Only the original idea + input materials
            run_prompt="$step_prompt

$FULL_PROMPT"
            ;;

        previous)
            # Original prompt + previous step's output only
            prev=$((i - 1))
            prev_file=$(get_step_var "$prev" OUTPUT_FILE)
            prev_output=""
            if [ -n "$prev_file" ] && [ -f "$prev_file" ]; then
                prev_output=$(cat "$prev_file")
            fi
            run_prompt="$step_prompt

ORIGINAL REQUEST:
$FULL_PROMPT

PREVIOUS ANALYSIS:
$prev_output"
            ;;

        all_previous)
            # Original prompt + all previous step outputs (consolidation)
            all_context=""
            for j in $(seq 1 $((i - 1))); do
                prev_name=$(get_step_var "$j" NAME)
                prev_file=$(get_step_var "$j" OUTPUT_FILE)
                if [ -n "$prev_file" ] && [ -f "$prev_file" ]; then
                    all_context="$all_context

$prev_name: $(cat "$prev_file")"
                fi
            done
            run_prompt="$step_prompt

ORIGINAL REQUEST:
$FULL_PROMPT
$all_context"
            # Track this as the consolidation file
            CONSOLIDATION_FILE="$output_file"
            ;;

        consolidation)
            # Original prompt + consolidation output only
            consol_output=""
            if [ -n "$CONSOLIDATION_FILE" ] && [ -f "$CONSOLIDATION_FILE" ]; then
                consol_output=$(cat "$CONSOLIDATION_FILE")
            fi
            run_prompt="$step_prompt

ORIGINAL REQUEST:
$FULL_PROMPT

Master plan: $consol_output"
            ;;

        *)
            # Fallback: treat like previous
            prev=$((i - 1))
            prev_file=$(get_step_var "$prev" OUTPUT_FILE)
            prev_output=""
            if [ -n "$prev_file" ] && [ -f "$prev_file" ]; then
                prev_output=$(cat "$prev_file")
            fi
            run_prompt="$step_prompt

ORIGINAL REQUEST:
$FULL_PROMPT

PREVIOUS ANALYSIS:
$prev_output"
            ;;
    esac

    "$VERN_RUN" "$step_llm" "$run_prompt" "$output_file" "$step_persona"

    # Store output file path for later steps to reference
    eval "STEP_${i}_OUTPUT_FILE=\"$output_file\""
done

# ── Post-processing: split architect breakdown into VTS task files ────────────
# The last step (architect breakdown) outputs tasks in a single file. Split them
# into individual Vern Task Spec (VTS) files in $OUTPUT_DIR/vts/ and rewrite
# the main file as a summary with a task index.

ARCHITECT_FILE=$(get_step_var "$PIPELINE_TOTAL" OUTPUT_FILE)

if [ -f "$ARCHITECT_FILE" ] && [ -s "$ARCHITECT_FILE" ] && command -v python3 &>/dev/null; then
    echo ""
    echo ">>> Splitting architect breakdown into VTS task files..."
    ARCHITECT_FILE="$ARCHITECT_FILE" FORMAT_DIR="$OUTPUT_DIR/vts" python3 << 'PYEOF'
import re, os, sys

architect_file = os.environ['ARCHITECT_FILE']
format_dir = os.environ['FORMAT_DIR']

with open(architect_file) as f:
    content = f.read()

# Find all task headers: ### TASK N: Title (also matches ## and alternate separators)
task_pattern = re.compile(r'^#{2,3}\s+Task\s+(\d+)\s*[:\.—]\s*(.+)', re.MULTILINE | re.IGNORECASE)
matches = list(task_pattern.finditer(content))

if not matches:
    print("  No tasks found in architect breakdown, skipping split")
    sys.exit(0)

# Header: everything before the first task
header = content[:matches[0].start()].rstrip('\n- ')

# Footer: first ## header (h2, not h3) after the last task — these are summary
# sections like "## Dependency Graph", "## Failure Modes", "## Total Estimate"
footer = ''
last_task_pos = matches[-1].start()
remaining = content[last_task_pos:]
footer_match = re.search(r'^## (?!#)', remaining, re.MULTILINE)
if footer_match:
    footer_abs = last_task_pos + footer_match.start()
    # Strip any trailing --- separator before the footer
    pre = content[:footer_abs].rstrip()
    if pre.endswith('---'):
        footer_abs = len(pre) - 3
    footer = content[footer_abs:].lstrip('-').strip()
else:
    footer_abs = len(content)

# Extract individual tasks
tasks = []
for idx, match in enumerate(matches):
    task_num = int(match.group(1))
    task_title = match.group(2).strip()
    start = match.start()
    end = matches[idx + 1].start() if idx + 1 < len(matches) else footer_abs

    task_body = content[start:end].rstrip()
    # Remove trailing --- separator between tasks
    if task_body.endswith('---'):
        task_body = task_body[:-3].rstrip()
    tasks.append((task_num, task_title, task_body))

def slugify(s):
    return re.sub(r'-+', '-', re.sub(r'[^a-z0-9]+', '-', s.lower())).strip('-')

def extract_field(body, field):
    """Extract a markdown bold field value from task body."""
    m = re.search(r'\*\*' + field + r':\*\*\s*(.+)', body)
    return m.group(1).strip() if m else ''

def extract_list(body, field):
    """Extract a markdown bold field followed by a bullet list."""
    # Try inline list first (comma-separated)
    m = re.search(r'\*\*' + field + r':\*\*\s*(.+)', body)
    if m:
        val = m.group(1).strip()
        if val.lower() not in ('none', 'n/a', '-', ''):
            return [v.strip().lstrip('- ') for v in re.split(r'[,;]', val) if v.strip()]
    # Try bullet list after the header
    m = re.search(r'\*\*' + field + r':\*\*\s*\n((?:\s*[-*]\s+.+\n?)+)', body)
    if m:
        return [line.strip().lstrip('-* ') for line in m.group(1).strip().split('\n') if line.strip()]
    return []

def extract_dependencies(body):
    """Extract dependency task IDs from body."""
    deps_raw = extract_field(body, 'Dependencies')
    if not deps_raw or deps_raw.lower() in ('none', 'n/a', '-'):
        return []
    # Extract task numbers like "Task 1", "Task 2, Task 3", "#1, #2"
    nums = re.findall(r'(?:Task\s+|#)(\d+)', deps_raw, re.IGNORECASE)
    return ['VTS-{:03d}'.format(int(n)) for n in nums]

def extract_files(body):
    """Extract file paths mentioned in the task body."""
    files_raw = extract_list(body, 'Files')
    if files_raw:
        return files_raw
    # Also try "Files Touched" or "Files Affected"
    for variant in ('Files Touched', 'Files Affected', 'Key Files'):
        files_raw = extract_list(body, variant)
        if files_raw:
            return files_raw
    return []

# Write individual VTS task files
os.makedirs(format_dir, exist_ok=True)
for task_num, task_title, task_body in tasks:
    task_id = 'VTS-{:03d}'.format(task_num)
    complexity = extract_field(task_body, 'Complexity') or '?'
    # Normalize complexity to valid values
    cx_upper = complexity.upper().strip('*').strip()
    if cx_upper in ('S', 'M', 'L', 'XL'):
        complexity = cx_upper
    deps = extract_dependencies(task_body)
    criteria = extract_list(task_body, 'Acceptance Criteria')
    files = extract_files(task_body)

    # Extract description (text after title, before first bold field)
    desc_match = re.search(r'^#{2,3}\s+Task\s+\d+.*\n+(.*?)(?=\n\*\*|\Z)', task_body, re.DOTALL | re.IGNORECASE)
    description = ''
    if desc_match:
        description = desc_match.group(1).strip()
    # Also try **Description:** field
    desc_field = extract_field(task_body, 'Description')
    if desc_field:
        description = desc_field

    # Build VTS frontmatter
    vts_lines = ['---']
    vts_lines.append('id: {}'.format(task_id))
    vts_lines.append('title: "{}"'.format(task_title.replace('"', '\\"')))
    vts_lines.append('complexity: {}'.format(complexity))
    vts_lines.append('status: pending')
    vts_lines.append('owner: ""')
    vts_lines.append('source: discovery')
    vts_lines.append('source_ref: "{}"'.format(os.path.basename(architect_file)))
    if deps:
        vts_lines.append('dependencies:')
        for d in deps:
            vts_lines.append('  - {}'.format(d))
    else:
        vts_lines.append('dependencies: []')
    if files:
        vts_lines.append('files:')
        for fp in files:
            vts_lines.append('  - "{}"'.format(fp))
    else:
        vts_lines.append('files: []')
    vts_lines.append('---')
    vts_lines.append('')

    # Body: description + criteria
    vts_lines.append('# {}'.format(task_title))
    vts_lines.append('')
    if description:
        vts_lines.append(description)
        vts_lines.append('')
    if criteria:
        vts_lines.append('## Criteria')
        vts_lines.append('')
        for c in criteria:
            vts_lines.append('- {}'.format(c))
        vts_lines.append('')

    filename = "vts-{:03d}-{}.md".format(task_num, slugify(task_title))
    with open(os.path.join(format_dir, filename), 'w') as f:
        f.write('\n'.join(vts_lines))
    print("  Created: vts/{}".format(filename))

# Build task index table for the summary
lines = []
lines.append("| ID | Task | Complexity | Dependencies |")
lines.append("|----|------|------------|--------------|")
for task_num, task_title, task_body in tasks:
    task_id = 'VTS-{:03d}'.format(task_num)
    cx = extract_field(task_body, 'Complexity') or '?'
    deps = extract_dependencies(task_body)
    dep_str = ', '.join(deps) if deps else 'None'
    lines.append("| {} | {} | {} | {} |".format(task_id, task_title, cx, dep_str))
task_index = '\n'.join(lines)

# Rewrite the architect file as a summary
with open(architect_file, 'w') as f:
    f.write(header + '\n\n')
    f.write("## VTS Task Index\n\n")
    f.write("Individual VTS files: `vts/`\n\n")
    f.write(task_index + '\n')
    if footer:
        f.write('\n' + footer + '\n')

print("  Rewrote {} as summary ({} VTS tasks extracted)".format(
    os.path.basename(architect_file), len(tasks)))
PYEOF
fi

echo ""
echo "=== DISCOVERY COMPLETE ==="
echo "Files created in: $DISCOVERY_DIR"
echo ""
echo "Structure:"
echo "  $DISCOVERY_DIR/"
echo "  ├── input/"
ls "$INPUT_DIR" 2>/dev/null | while read -r f; do echo "  │   ├── $f"; done
echo "  └── output/"
ls "$OUTPUT_DIR" 2>/dev/null | while read -r f; do echo "      ├── $f"; done

# VernHole: batch mode uses flag, interactive mode asks
# Use the dynamically tracked consolidation file
if [ -z "$CONSOLIDATION_FILE" ]; then
    # Fallback: find the consolidation file by name pattern
    CONSOLIDATION_FILE=$(ls "$OUTPUT_DIR"/*consolidation*.md 2>/dev/null | head -1)
fi

RAN_VERNHOLE=0

if [ "$BATCH_MODE" -eq 1 ]; then
    if [ "$VERNHOLE_COUNT" -gt 0 ] || [ -n "$VERNHOLE_COUNCIL" ]; then
        echo ""
        echo "=== ENTERING THE VERNHOLE ==="
        echo "Feeding original idea + master plan into the chaos..."
        mkdir -p "$DISCOVERY_DIR/vernhole"
        if [ -n "$VERNHOLE_COUNCIL" ]; then
            "$SCRIPT_DIR/vernhole" --council "$VERNHOLE_COUNCIL" "$IDEA" "$DISCOVERY_DIR/vernhole" "" "$CONSOLIDATION_FILE"
        else
            "$SCRIPT_DIR/vernhole" "$IDEA" "$DISCOVERY_DIR/vernhole" "$VERNHOLE_COUNT" "$CONSOLIDATION_FILE"
        fi
        RAN_VERNHOLE=1
    fi
else
    echo ""
    read -p ">>> Do you want to run a VernHole (k-hole) on the synthesised plan? [y/N] " RUN_KHOLE
    if [[ "$RUN_KHOLE" =~ ^[Yy]$ ]]; then
        echo ""
        echo "=== ENTERING THE VERNHOLE ==="
        echo "Feeding original idea + master plan into the chaos..."
        mkdir -p "$DISCOVERY_DIR/vernhole"
        "$SCRIPT_DIR/vernhole" "$IDEA" "$DISCOVERY_DIR/vernhole" "" "$CONSOLIDATION_FILE"
        RAN_VERNHOLE=1
    fi
fi

# ── Oracle Vern: bridge VernHole synthesis + VTS → oracle-vision.md ──────────
# Only runs if VernHole was run (synthesis.md must exist)

SYNTHESIS_FILE="$DISCOVERY_DIR/vernhole/synthesis.md"

if [ "$RAN_VERNHOLE" -eq 1 ] && [ -f "$SYNTHESIS_FILE" ]; then
    RUN_ORACLE=0
    APPLY_MODE=""

    if [ "$BATCH_MODE" -eq 1 ]; then
        if [ "$ORACLE_FLAG" -eq 1 ]; then
            RUN_ORACLE=1
            if [ "$ORACLE_APPLY_FLAG" -eq 1 ]; then
                APPLY_MODE="auto"
            else
                APPLY_MODE="manual"
            fi
        fi
    else
        echo ""
        read -p ">>> Consult Oracle Vern on the VernHole synthesis + VTS tasks? [y/N] " RUN_ORACLE_ANSWER
        if [[ "$RUN_ORACLE_ANSWER" =~ ^[Yy]$ ]]; then
            RUN_ORACLE=1
            echo ""
            echo "How should the Oracle's vision be applied?"
            echo "  1. manual  - Review oracle-vision.md yourself (recommended)"
            echo "  2. auto    - Architect Vern rewrites VTS based on Oracle's vision"
            echo "  3. skip    - Create oracle-vision.md but don't apply"
            read -p ">>> Choose [manual/auto/skip]: " APPLY_MODE
            case "$APPLY_MODE" in
                auto|a|2) APPLY_MODE="auto" ;;
                skip|s|3) APPLY_MODE="skip" ;;
                *) APPLY_MODE="manual" ;;
            esac
        fi
    fi

    if [ "$RUN_ORACLE" -eq 1 ]; then
        echo ""
        echo "=== CONSULTING THE ORACLE ==="
        echo "Reading the VernHole synthesis and VTS tasks..."

        # Build VTS task contents
        VTS_CONTENTS=""
        VTS_INDEX=""
        if [ -d "$OUTPUT_DIR/vts" ]; then
            for vts_file in "$OUTPUT_DIR"/vts/vts-*.md; do
                if [ -f "$vts_file" ]; then
                    VTS_INDEX="$VTS_INDEX
- $(basename "$vts_file")"
                    VTS_CONTENTS="$VTS_CONTENTS

=== $(basename "$vts_file") ===
$(cat "$vts_file")"
                fi
            done
        fi

        SYNTHESIS_CONTENTS=$(cat "$SYNTHESIS_FILE")

        ORACLE_PROMPT="You are Oracle Vern. The ancient seer who reads the patterns in the Vern council's chaos.

Review these VTS tasks in light of the Vern council's synthesis. Recommend modifications: new tasks to add, tasks to modify, tasks to remove, dependency changes, complexity reassessments, and missing acceptance criteria.

Output as a structured vision document with these sections:
# Oracle Vision

## Summary
Brief overview of recommended changes.

## New Tasks
(Use ### TASK N+1: Title format — same format as the architect breakdown so it can be parsed by the VTS post-processor)

## Modified Tasks
### VTS-NNN: New Title (was: Old Title)
**Changes:** What changed and why
**Description:** ...
**Acceptance Criteria:** ...
**Complexity:** ...
**Dependencies:** ...

## Removed Tasks
- VTS-NNN: Reason for removal

## Dependency Changes
- Describe any dependency modifications

## Risk Assessment
Remaining risks after your recommended modifications.

ORIGINAL IDEA:
$FULL_PROMPT

VTS TASK INDEX:
$VTS_INDEX

VTS TASK FILES:
$VTS_CONTENTS

VERNHOLE SYNTHESIS:
$SYNTHESIS_CONTENTS"

        ORACLE_VISION_FILE="$DISCOVERY_DIR/oracle-vision.md"
        "$VERN_RUN" claude "$ORACLE_PROMPT" "$ORACLE_VISION_FILE" "oracle"

        echo ""
        echo "Oracle vision written to: $ORACLE_VISION_FILE"

        # Auto-apply: Architect Vern rewrites VTS based on Oracle's vision
        if [ "$APPLY_MODE" = "auto" ]; then
            echo ""
            echo "=== APPLYING THE ORACLE'S VISION ==="
            echo "Architect Vern is rewriting VTS tasks..."

            ORACLE_VISION_CONTENTS=$(cat "$ORACLE_VISION_FILE")

            ARCHITECT_APPLY_PROMPT="You are Architect Vern. The Oracle has spoken. Apply the Oracle's vision to produce an updated task breakdown.

Read the Oracle's vision and the existing VTS tasks. Produce a complete, updated task breakdown incorporating the Oracle's recommendations (new tasks, modified tasks, removed tasks, dependency changes).

Format each task with an h3 header exactly like this: ### TASK 1: Title Here. Include for each task: **Description:** what needs to be done, **Acceptance Criteria:** bullet list, **Complexity:** S|M|L|XL, **Dependencies:** Task N references or None, **Files:** list of files likely touched.

ORACLE'S VISION:
$ORACLE_VISION_CONTENTS

EXISTING VTS TASKS:
$VTS_CONTENTS

Produce the complete updated task breakdown. Include ALL tasks (not just changed ones)."

            UPDATED_ARCHITECT_FILE="$OUTPUT_DIR/oracle-architect-breakdown.md"
            "$VERN_RUN" claude "$ARCHITECT_APPLY_PROMPT" "$UPDATED_ARCHITECT_FILE" "architect"

            # Re-run VTS post-processor on the updated architect file
            if [ -f "$UPDATED_ARCHITECT_FILE" ] && [ -s "$UPDATED_ARCHITECT_FILE" ] && command -v python3 &>/dev/null; then
                echo ""
                echo ">>> Re-splitting updated architect breakdown into VTS task files..."
                # Clear old VTS files
                rm -f "$OUTPUT_DIR"/vts/vts-*.md
                ARCHITECT_FILE="$UPDATED_ARCHITECT_FILE" FORMAT_DIR="$OUTPUT_DIR/vts" python3 << 'PYEOF'
import re, os, sys

architect_file = os.environ['ARCHITECT_FILE']
format_dir = os.environ['FORMAT_DIR']

with open(architect_file) as f:
    content = f.read()

task_pattern = re.compile(r'^#{2,3}\s+Task\s+(\d+)\s*[:\.—]\s*(.+)', re.MULTILINE | re.IGNORECASE)
matches = list(task_pattern.finditer(content))

if not matches:
    print("  No tasks found in updated architect breakdown, skipping split")
    sys.exit(0)

header = content[:matches[0].start()].rstrip('\n- ')

footer = ''
last_task_pos = matches[-1].start()
remaining = content[last_task_pos:]
footer_match = re.search(r'^## (?!#)', remaining, re.MULTILINE)
if footer_match:
    footer_abs = last_task_pos + footer_match.start()
    pre = content[:footer_abs].rstrip()
    if pre.endswith('---'):
        footer_abs = len(pre) - 3
    footer = content[footer_abs:].lstrip('-').strip()
else:
    footer_abs = len(content)

tasks = []
for idx, match in enumerate(matches):
    task_num = int(match.group(1))
    task_title = match.group(2).strip()
    start = match.start()
    end = matches[idx + 1].start() if idx + 1 < len(matches) else footer_abs
    task_body = content[start:end].rstrip()
    if task_body.endswith('---'):
        task_body = task_body[:-3].rstrip()
    tasks.append((task_num, task_title, task_body))

def slugify(s):
    return re.sub(r'-+', '-', re.sub(r'[^a-z0-9]+', '-', s.lower())).strip('-')

def extract_field(body, field):
    m = re.search(r'\*\*' + field + r':\*\*\s*(.+)', body)
    return m.group(1).strip() if m else ''

def extract_list(body, field):
    m = re.search(r'\*\*' + field + r':\*\*\s*(.+)', body)
    if m:
        val = m.group(1).strip()
        if val.lower() not in ('none', 'n/a', '-', ''):
            return [v.strip().lstrip('- ') for v in re.split(r'[,;]', val) if v.strip()]
    m = re.search(r'\*\*' + field + r':\*\*\s*\n((?:\s*[-*]\s+.+\n?)+)', body)
    if m:
        return [line.strip().lstrip('-* ') for line in m.group(1).strip().split('\n') if line.strip()]
    return []

def extract_dependencies(body):
    deps_raw = extract_field(body, 'Dependencies')
    if not deps_raw or deps_raw.lower() in ('none', 'n/a', '-'):
        return []
    nums = re.findall(r'(?:Task\s+|#)(\d+)', deps_raw, re.IGNORECASE)
    return ['VTS-{:03d}'.format(int(n)) for n in nums]

def extract_files(body):
    files_raw = extract_list(body, 'Files')
    if files_raw:
        return files_raw
    for variant in ('Files Touched', 'Files Affected', 'Key Files'):
        files_raw = extract_list(body, variant)
        if files_raw:
            return files_raw
    return []

os.makedirs(format_dir, exist_ok=True)
for task_num, task_title, task_body in tasks:
    task_id = 'VTS-{:03d}'.format(task_num)
    complexity = extract_field(task_body, 'Complexity') or '?'
    cx_upper = complexity.upper().strip('*').strip()
    if cx_upper in ('S', 'M', 'L', 'XL'):
        complexity = cx_upper
    deps = extract_dependencies(task_body)
    criteria = extract_list(task_body, 'Acceptance Criteria')
    files = extract_files(task_body)

    desc_match = re.search(r'^#{2,3}\s+Task\s+\d+.*\n+(.*?)(?=\n\*\*|\Z)', task_body, re.DOTALL | re.IGNORECASE)
    description = ''
    if desc_match:
        description = desc_match.group(1).strip()
    desc_field = extract_field(task_body, 'Description')
    if desc_field:
        description = desc_field

    vts_lines = ['---']
    vts_lines.append('id: {}'.format(task_id))
    vts_lines.append('title: "{}"'.format(task_title.replace('"', '\\"')))
    vts_lines.append('complexity: {}'.format(complexity))
    vts_lines.append('status: pending')
    vts_lines.append('owner: ""')
    vts_lines.append('source: oracle')
    vts_lines.append('source_ref: "{}"'.format(os.path.basename(architect_file)))
    if deps:
        vts_lines.append('dependencies:')
        for d in deps:
            vts_lines.append('  - {}'.format(d))
    else:
        vts_lines.append('dependencies: []')
    if files:
        vts_lines.append('files:')
        for fp in files:
            vts_lines.append('  - "{}"'.format(fp))
    else:
        vts_lines.append('files: []')
    vts_lines.append('---')
    vts_lines.append('')
    vts_lines.append('# {}'.format(task_title))
    vts_lines.append('')
    if description:
        vts_lines.append(description)
        vts_lines.append('')
    if criteria:
        vts_lines.append('## Criteria')
        vts_lines.append('')
        for c in criteria:
            vts_lines.append('- {}'.format(c))
        vts_lines.append('')

    filename = "vts-{:03d}-{}.md".format(task_num, slugify(task_title))
    with open(os.path.join(format_dir, filename), 'w') as f:
        f.write('\n'.join(vts_lines))
    print("  Created: vts/{}".format(filename))

lines = []
lines.append("| ID | Task | Complexity | Dependencies |")
lines.append("|----|------|------------|--------------|")
for task_num, task_title, task_body in tasks:
    task_id = 'VTS-{:03d}'.format(task_num)
    cx = extract_field(task_body, 'Complexity') or '?'
    deps = extract_dependencies(task_body)
    dep_str = ', '.join(deps) if deps else 'None'
    lines.append("| {} | {} | {} | {} |".format(task_id, task_title, cx, dep_str))
task_index = '\n'.join(lines)

with open(architect_file, 'w') as f:
    f.write(header + '\n\n')
    f.write("## VTS Task Index (Oracle-Updated)\n\n")
    f.write("Individual VTS files: `vts/`\n\n")
    f.write(task_index + '\n')
    if footer:
        f.write('\n' + footer + '\n')

print("  Rewrote {} as summary ({} VTS tasks extracted)".format(
    os.path.basename(architect_file), len(tasks)))
PYEOF
            fi

            echo ""
            echo "Oracle's vision applied. Updated VTS files in: $OUTPUT_DIR/vts/"
        elif [ "$APPLY_MODE" = "manual" ]; then
            echo "Review oracle-vision.md and update VTS files manually."
        fi
    fi
fi
